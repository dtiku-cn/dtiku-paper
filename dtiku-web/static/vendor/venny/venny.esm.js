function e(e) {const t = new Array(e);for (let n = 0; n < e; ++n) t[n] = 0;return t;}function t(t, n) {return e(t).map(function () {return e(n);});}function n(e, t) {let n = 0;for (let s = 0; s < e.length; ++s) n += e[s] * t[s];return n;}function s(e) {return Math.sqrt(n(e, e));}function i(e, t, n) {for (let s = 0; s < t.length; ++s) e[s] = t[s] * n;}function r(e, t, n, s, i) {for (let r = 0; r < e.length; ++r) e[r] = t * n[r] + s * i[r];}function o(e, t, s, i, o, a, l) {const h = s.fx,c = n(s.fxprime, t);let f = h,u = h,d = c,g = 0,p = o || 1;const x = a || 1e-6,m = l || .1,y = (o, a, l) => {for (let u = 0; u < 16; ++u) if (p = (o + a) / 2, r(i.x, 1, s.x, p, t), f = i.fx = e(i.x, i.fxprime), d = n(i.fxprime, t), f > h + x * p * c || f >= l) a = p;else {if (Math.abs(d) <= -m * c) return p;d * (a - o) >= 0 && (a = o), o = p, l = f;}return 0;};for (let o = 0; o < 10; ++o) {if (r(i.x, 1, s.x, p, t), f = i.fx = e(i.x, i.fxprime), d = n(i.fxprime, t), f > h + x * p * c || o && f >= u) return y(g, p, u);if (Math.abs(d) <= -m * c) return p;if (d >= 0) return y(p, g, f);u = f, g = p, p *= 2;}return p;}function a(e, t, a) {let l,h = { x: t.slice(), fx: 0, fxprime: t.slice() },c = { x: t.slice(), fx: 0, fxprime: t.slice() };const f = t.slice();let u = 1;const d = (a = a || {}).maxIterations || 20 * t.length;h.fx = e(h.x, h.fxprime);const g = h.fxprime.slice();i(g, h.fxprime, -1);for (let t = 0; t < d; ++t) {if (u = o(e, g, h, c, u), a.history && a.history.push({ x: h.x.slice(), fx: h.fx, fxprime: h.fxprime.slice(), alpha: u }), u) {r(f, 1, c.fxprime, -1, h.fxprime);const e = n(h.fxprime, h.fxprime);r(g, Math.max(0, n(f, c.fxprime) / e), g, -1, c.fxprime), l = h, h = c, c = l;} else i(g, h.fxprime, -1);if (s(h.fxprime) <= 1e-5) break;}return a.history && a.history.push({ x: h.x.slice(), fx: h.fx, fxprime: h.fxprime.slice(), alpha: u }), h;}function l(e, t, n) {const s = (n = n || {}).maxIterations || 200 * t.length,i = n.nonZeroDelta || 1.05,o = n.zeroDelta || .001,a = n.minErrorDelta || 1e-6,l = n.minErrorDelta || 1e-5,h = void 0 !== n.rho ? n.rho : 1,c = void 0 !== n.chi ? n.chi : 2,f = void 0 !== n.psi ? n.psi : -.5,u = void 0 !== n.sigma ? n.sigma : .5,d = t.length,g = new Array(d + 1);g[0] = t, g[0].fx = e(t), g[0].id = 0;for (let n = 0; n < d; ++n) {const s = t.slice();s[n] = s[n] ? s[n] * i : o, g[n + 1] = s, g[n + 1].fx = e(s), g[n + 1].id = n + 1;}function p(e) {for (let t = 0; t < e.length; t++) g[d][t] = e[t];g[d].fx = e.fx;}const x = function (e, t) {return e.fx - t.fx;},m = t.slice(),y = t.slice(),v = t.slice(),_ = t.slice();for (let t = 0; t < s; ++t) {if (g.sort(x), n.history) {const e = g.map(e => {const t = e.slice();return t.fx = e.fx, t.id = e.id, t;});e.sort(function (e, t) {return e.id - t.id;}), n.history.push({ x: g[0].slice(), fx: g[0].fx, simplex: e });}let t = 0;for (let e = 0; e < d; ++e) t = Math.max(t, Math.abs(g[0][e] - g[1][e]));if (Math.abs(g[0].fx - g[d].fx) < a && t < l) break;for (let e = 0; e < d; ++e) {m[e] = 0;for (let t = 0; t < d; ++t) m[e] += g[t][e];m[e] /= d;}const s = g[d];if (r(y, 1 + h, m, -h, s), y.fx = e(y), y.fx < g[0].fx) r(_, 1 + c, m, -c, s), _.fx = e(_), _.fx < y.fx ? p(_) : p(y);else if (y.fx >= g[d - 1].fx) {let t = !1;if (y.fx > s.fx ? (r(v, 1 + f, m, -f, s), v.fx = e(v), v.fx < s.fx ? p(v) : t = !0) : (r(v, 1 - f * h, m, f * h, s), v.fx = e(v), v.fx < y.fx ? p(v) : t = !0), t) {if (u >= 1) break;for (let t = 1; t < g.length; ++t) r(g[t], 1 - u, g[0], u, g[t]), g[t].fx = e(g[t]);}} else p(y);}return g.sort(x), { fx: g[0].fx, x: g[0] };}function h(e, t) {const n = function (e) {const t = [];for (let n = 0; n < e.length; ++n) for (let s = n + 1; s < e.length; ++s) {const i = d(e[n], e[s]);for (let e = 0; e < i.length; ++e) {const r = i[e];t.push({ x: r.x, y: r.y, parentIndex: [n, s], angle: 0 });}}return t;}(e),s = n.filter(function (t) {return function (e, t) {for (let n = 0; n < t.length; ++n) if (f(e, t[n]) > t[n].radius + 1e-10) return !1;return !0;}(t, e);});let i = 0,r = 0;const o = [];if (s.length > 1) {const t = g(s);for (let e = 0; e < s.length; ++e) {const n = s[e];n.angle = Math.atan2(n.x - t.x, n.y - t.y);}s.sort(function (e, t) {return t.angle - e.angle;});let n = s[s.length - 1];for (let t = 0; t < s.length; ++t) {const a = s[t];r += (n.x + a.x) * (a.y - n.y);const l = { x: (a.x + n.x) / 2, y: (a.y + n.y) / 2 };let h = null;for (let t = 0; t < a.parentIndex.length; ++t) if (n.parentIndex.indexOf(a.parentIndex[t]) > -1) {const s = e[a.parentIndex[t]],i = Math.atan2(a.x - s.x, a.y - s.y),r = Math.atan2(n.x - s.x, n.y - s.y);let o = r - i;o < 0 && (o += 2 * Math.PI);const c = r - o / 2;let u = f(l, { x: s.x + s.radius * Math.sin(c), y: s.y + s.radius * Math.cos(c) });u > 2 * s.radius && (u = 2 * s.radius), (null === h || h.width > u) && (h = { circle: s, width: u, p1: a, p2: n });}null !== h && (o.push(h), i += c(h.circle.radius, h.width), n = a);}} else {let t = e[0];for (let n = 1; n < e.length; ++n) e[n].radius < t.radius && (t = e[n]);let n = !1;for (let s = 0; s < e.length; ++s) if (f(e[s], t) > Math.abs(t.radius - e[s].radius)) {n = !0;break;}n ? i = r = 0 : (i = t.radius * t.radius * Math.PI, o.push({ circle: t, p1: { x: t.x, y: t.y + t.radius }, p2: { x: t.x - 1e-10, y: t.y + t.radius }, width: 2 * t.radius }));}return r /= 2, t && (t.area = i + r, t.arcArea = i, t.polygonArea = r, t.arcs = o, t.innerPoints = s, t.intersectionPoints = n), i + r;}function c(e, t) {return e * e * Math.acos(1 - t / e) - (e - t) * Math.sqrt(t * (2 * e - t));}function f(e, t) {return Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y));}function u(e, t, n) {if (n >= e + t) return 0;if (n <= Math.abs(e - t)) return Math.PI * Math.min(e, t) * Math.min(e, t);const s = t - (n * n - e * e + t * t) / (2 * n);return c(e, e - (n * n - t * t + e * e) / (2 * n)) + c(t, s);}function d(e, t) {const n = f(e, t),s = e.radius,i = t.radius;if (n >= s + i || n <= Math.abs(s - i)) return [];const r = (s * s - i * i + n * n) / (2 * n),o = Math.sqrt(s * s - r * r),a = e.x + r * (t.x - e.x) / n,l = e.y + r * (t.y - e.y) / n,h = -(t.y - e.y) * (o / n),c = -(t.x - e.x) * (o / n);return [{ x: a + h, y: l - c }, { x: a - h, y: l + c }];}function g(e) {const t = { x: 0, y: 0 };for (let n = 0; n < e.length; ++n) t.x += e[n].x, t.y += e[n].y;return t.x /= e.length, t.y /= e.length, t;}function p(e, t) {(t = t || {}).maxIterations = t.maxIterations || 500;const n = t.initialLayout || m,s = t.lossFunction || y,i = n(e = function (e) {e = e.slice();const t = [],n = new Map();for (let s = 0; s < e.length; ++s) {const i = e[s];if (1 === i.sets.length) t.push(i.sets[0]);else if (2 === i.sets.length) {const e = i.sets[0],t = i.sets[1];n.set([e, t].join(","), !0), n.set([t, e].join(","), !0);}}t.sort((e, t) => e > t ? 1 : 0);for (let s = 0; s < t.length; ++s) {const i = t[s];for (let r = s + 1; r < t.length; ++r) {const s = t[r];n.has([i, s].join(",")) || e.push({ sets: [i, s], size: 0 });}}return e;}(e), t),r = [],o = [];for (const e in i) i[e] && (r.push(i[e].x), r.push(i[e].y), o.push(e));const a = l(t => {const n = {};for (let e = 0; e < o.length; ++e) {const s = o[e];n[s] = { x: t[2 * e], y: t[2 * e + 1], radius: i[s].radius };}return s(n, e);}, r, t).x;for (let e = 0; e < o.length; ++e) {const t = o[e];i[t].x = a[2 * e], i[t].y = a[2 * e + 1];}return i;}function x(e, t, n) {return Math.min(e, t) * Math.min(e, t) * Math.PI <= n + 1e-10 ? Math.abs(e - t) : function (e, t, n, s) {const i = (s = s || {}).maxIterations || 100,r = s.tolerance || 1e-10,o = e(t),a = e(n);let l = n - t;if (o * a > 0) throw new Error("Initial bisect points must have opposite signs");if (0 === o) return t;if (0 === a) return n;for (let n = 0; n < i; ++n) {l /= 2;const n = t + l,s = e(n);if (s * o >= 0 && (t = n), Math.abs(l) < r || 0 === s) return n;}return t + l;}(s => u(e, t, s) - n, 0, e + t);}function m(n, r) {let o = function (e, t) {const n = t && t.lossFunction ? t.lossFunction : y,s = {},i = {};for (let t = 0; t < e.length; ++t) {const n = e[t];if (1 === n.sets.length) {const e = n.sets[0];s[e] = { x: 1e10, y: 1e10, rowid: s.length, size: n.size, radius: Math.sqrt(n.size / Math.PI) }, i[e] = [];}}e = e.filter(function (e) {return 2 === e.sets.length;});for (let t = 0; t < e.length; ++t) {const n = e[t];let r = "number" == typeof n.weight ? n.weight : 1;const o = n.sets[0],a = n.sets[1];s[o] && s[a] && (n.size + 1e-10 >= Math.min(s[o].size || 0, s[a].size || 0) && (r = 0), i[o].push({ set: a, size: n.size, weight: r }), i[a].push({ set: o, size: n.size, weight: r }));}const r = [];for (const e in i) if (void 0 !== i[e]) {let t = 0;for (let n = 0; n < i[e].length; ++n) t += i[e][n].size * i[e][n].weight;r.push({ set: e, size: t });}const o = (e, t) => t.size - e.size;r.sort(o);const a = {},l = e => e.set in a,h = (e, t) => {s[t].x = e.x, s[t].y = e.y, a[t] = !0;};h({ x: 0, y: 0 }, r[0].set);for (let t = 1; t < r.length; ++t) {const a = r[t].set,c = i[a].filter(l),f = s[a];if (c.sort(o), 0 === c.length) throw new Error("ERROR: missing pairwise overlap information");const u = [];for (let e = 0; e < c.length; ++e) {const t = s[c[e].set],n = x(f.radius, t.radius, c[e].size);u.push({ x: t.x + n, y: t.y }), u.push({ x: t.x - n, y: t.y }), u.push({ y: t.y + n, x: t.x }), u.push({ y: t.y - n, x: t.x });for (let i = e + 1; i < c.length; ++i) {const e = s[c[i].set],r = x(f.radius, e.radius, c[i].size),o = d({ x: t.x, y: t.y, radius: n }, { x: e.x, y: e.y, radius: r });for (let e = 0; e < o.length; ++e) u.push(o[e]);}}let g = 1e50,p = u[0];for (let t = 0; t < u.length; ++t) {s[a].x = u[t].x, s[a].y = u[t].y;const i = n(s, e);i < g && (g = i, p = u[t]);}h(p, a);}return s;}(n, r);const l = r.lossFunction || y;if (n.length >= 8) {const h = function (n, r) {const o = (r = r || {}).restarts || 10,l = [],h = {};for (let e = 0; e < n.length; ++e) {const t = n[e];1 === t.sets.length && (h[t.sets[0]] = l.length, l.push(t));}const c = function (e, n, s) {const i = t(n.length, n.length),r = t(n.length, n.length);return e.filter(function (e) {return !(2 !== e.sets.length || !s[e.sets[0]] || !s[e.sets[1]]);}).map(function (e) {const t = s[e.sets[0]],o = s[e.sets[1]],a = x(Math.sqrt(n[t].size / Math.PI), Math.sqrt(n[o].size / Math.PI), e.size);i[t][o] = i[o][t] = a;let l = 0;e.size + 1e-10 >= Math.min(n[t].size, n[o].size) ? l = 1 : e.size <= 1e-10 && (l = -1), r[t][o] = r[o][t] = l;}), { distances: i, constraints: r };}(n, l, h);let f = c.distances;const u = c.constraints,d = s(f.map(s)) / f.length;f = f.map(function (e) {return e.map(function (e) {return e / d;});});const g = (e, t) => function (e, t, n, s) {let i = 0;for (let e = 0; e < t.length; ++e) t[e] = 0;for (let r = 0; r < n.length; ++r) {const o = e[2 * r],a = e[2 * r + 1];for (let l = r + 1; l < n.length; ++l) {const h = e[2 * l],c = e[2 * l + 1],f = n[r][l],u = s[r][l],d = (h - o) * (h - o) + (c - a) * (c - a),g = Math.sqrt(d),p = d - f * f;u > 0 && g <= f || u < 0 && g >= f || (i += 2 * p * p, t[2 * r] += 4 * p * (o - h), t[2 * r + 1] += 4 * p * (a - c), t[2 * l] += 4 * p * (h - o), t[2 * l + 1] += 4 * p * (c - a));}}return i;}(e, t, f, u);let p = null,m = null;for (let t = 0; t < o; ++t) {m = a(g, e(2 * f.length).map(Math.random), r), (!p || m.fx < p.fx) && (p = m);}const y = (null == p ? void 0 : p.x) || [],v = {};for (let e = 0; e < l.length; ++e) {const t = l[e];v[t.sets[0]] = { x: y[2 * e] * d, y: y[2 * e + 1] * d, radius: Math.sqrt(t.size / Math.PI) };}if (r.history) for (let e = 0; e < r.history.length; ++e) i(r.history[e].x, r.history[e].x, d);return v;}(n, r);l(h, n) + 1e-8 < l(o, n) && (o = h);}return o;}function y(e, t) {let n = 0;for (let s = 0; s < t.length; ++s) {const i = t[s];let r = 0;if (1 === i.sets.length) continue;if (2 === i.sets.length) {const t = e[i.sets[0]],n = e[i.sets[1]];if (!t || !n) continue;r = u(t.radius, n.radius, f(t, n));} else r = h(i.sets.map(t => e[t]).filter(e => !!e));n += ("number" == typeof i.weight ? i.weight : 1) * (r - i.size) * (r - i.size);}return n;}function v(e, t, n) {if (void 0 === n ? e.sort(function (e, t) {return t.radius - e.radius;}) : e.sort(n), e.length > 0) {const t = e[0].x,n = e[0].y;for (let s = 0; s < e.length; ++s) e[s].x -= t, e[s].y -= n;}if (2 === e.length) {f(e[0], e[1]) < Math.abs(e[1].radius - e[0].radius) && (e[1].x = e[0].x + e[0].radius - e[1].radius - 1e-10, e[1].y = e[0].y);}if (e.length > 1) {const n = Math.atan2(e[1].x, e[1].y) - t,s = Math.cos(n),i = Math.sin(n);for (let t = 0; t < e.length; ++t) {const n = e[t].x,r = e[t].y;e[t].x = s * n - i * r, e[t].y = i * n + s * r;}}if (e.length > 2) {let n = Math.atan2(e[2].x, e[2].y) - t;for (; n < 0;) n += 2 * Math.PI;for (; n > 2 * Math.PI;) n -= 2 * Math.PI;if (n > Math.PI) {const t = e[1].y / (1e-10 + e[1].x);for (let n = 0; n < e.length; ++n) {const s = (e[n].x + t * e[n].y) / (1 + t * t);e[n].x = 2 * s - e[n].x, e[n].y = 2 * s * t - e[n].y;}}}}function _(e) {const t = function (t) {return { max: Math.max.apply(null, e.map(e => e[t] + e.radius)), min: Math.min.apply(null, e.map(e => e[t] - e.radius)) };};return { xRange: t("x"), yRange: t("y") };}function b(e, t, n) {null === t && (t = Math.PI / 2);let s = [];for (const t in e) {const n = e[t];s.push({ x: n.x, y: n.y, radius: n.radius, setid: t });}const i = function (e) {e.map(function (e) {e.parent = e;});const t = e => (e.parent !== e && (e.parent = t(e.parent)), e.parent),n = (e, n) => {const s = t(e),i = t(n);s.parent = i;};for (let t = 0; t < e.length; ++t) for (let s = t + 1; s < e.length; ++s) {const i = e[t].radius + e[s].radius;f(e[t], e[s]) + 1e-10 < i && n(e[s], e[t]);}const s = new Map();for (let n = 0; n < e.length; ++n) {const i = t(e[n]).parent.setid;i && (s.has(i) || s.set(i, []), s.get(i).push(e[n]));}e.map(function (e) {delete e.parent;});const i = [];for (const e of s.keys()) i.push(s.get(e));return i;}(s);for (let e = 0; e < i.length; ++e) {v(i[e], t, n);const s = _(i[e]);i[e].size = (s.xRange.max - s.xRange.min) * (s.yRange.max - s.yRange.min), i[e].bounds = s;}i.sort(function (e, t) {return t.size - e.size;}), s = i[0];let r = s.bounds;const o = (r.xRange.max - r.xRange.min) / 50,a = (e, t, n) => {if (!e) return;if (!e.bounds) return;const i = e.bounds;let a = 0,l = 0,h = 0;t ? a = r.xRange.max - i.xRange.min + o : (a = r.xRange.max - i.xRange.max, h = (i.xRange.max - i.xRange.min) / 2 - (r.xRange.max - r.xRange.min) / 2, h < 0 && (a += h)), n ? l = r.yRange.max - i.yRange.min + o : (l = r.yRange.max - i.yRange.max, h = (i.yRange.max - i.yRange.min) / 2 - (r.yRange.max - r.yRange.min) / 2, h < 0 && (l += h));for (let t = 0; t < e.length; ++t) e[t].x += a, e[t].y += l, s.push(e[t]);};let l = 1;for (; l < i.length;) a(i[l], !0, !1), a(i[l + 1], !1, !0), a(i[l + 2], !0, !0), l += 3, r = _(s);const h = {};for (let e = 0; e < s.length; ++e) {const t = s[e].setid;t && (h[t] = s[e]);}return h;}const w = { width: 600, height: 350, padding: 15, normalize: !0, orientation: Math.PI / 2 };function M(e, t) {const n = Object.assign({}, w, t || {});let s = e;const i = new Set();s.forEach(function (e) {0 === e.size && 1 === e.sets.length && i.add(e.sets[0]);}), s = s.filter(function (e) {return !e.sets.some(e => i.has(e));});let r = {},o = new Map();if (s.length) {let e = p(s, { lossFunction: y });n.normalize && (e = b(e, n.orientation, n.orientationOrder), r = function (e, t, n, s) {const i = [],r = [];for (const t in e) r.push(t), i.push(e[t]);t -= 2 * s, n -= 2 * s;const o = _(i),a = o.xRange,l = o.yRange;if (a.max === a.min || l.max === l.min) return e;const h = t / (a.max - a.min),c = n / (l.max - l.min),f = Math.min(c, h),u = (t - (a.max - a.min) * f) / 2,d = (n - (l.max - l.min) * f) / 2,g = {};for (let e = 0; e < i.length; ++e) {const t = i[e];g[r[e]] = { radius: f * t.radius, x: s + u + (t.x - a.min) * f, y: s + d + (t.y - l.min) * f };}return g;}(e, n.width, n.height, n.padding), o = function (e, t) {const n = new Map(),s = function (e) {var t, n;const s = new Map(),i = [];for (const t in e) i.push(t), s.set(t, []);for (let r = 0; r < i.length; r++) {const o = e[i[r]];for (let a = r + 1; a < i.length; ++a) {const l = e[i[a]],h = f(o, l);h + l.radius <= o.radius + 1e-10 ? null === (t = s.get(i[a])) || void 0 === t || t.push(i[r]) : h + o.radius <= l.radius + 1e-10 && (null === (n = s.get(i[r])) || void 0 === n || n.push(i[a]));}}return s;}(e);for (let i = 0; i < t.length; ++i) {const r = t[i].sets,o = new Set(),a = new Set();for (let e = 0; e < r.length; ++e) {o.add(r[e]);const t = s.get(r[e]) || [];for (let e = 0; e < t.length; ++e) a.add(t[e]);}const l = [],h = [];for (const t in e) o.has(t) ? l.push(e[t]) : a.has(t) || h.push(e[t]);const c = C(l, h);n.set(z(r), c), c.disjoint && t[i].size;}return n;}(r, s));}return { circles: r, textCenters: o };}function z(e) {return [...e].sort().join(",");}function k(e, t, n) {let s = t[0].radius - f(t[0], e);for (let n = 1; n < t.length; ++n) {const i = t[n].radius - f(t[n], e);i <= s && (s = i);}for (let t = 0; t < n.length; ++t) {const i = f(n[t], e) - n[t].radius;i <= s && (s = i);}return s;}function C(e, t) {const n = [];for (let t = 0; t < e.length; ++t) {const s = e[t];n.push({ x: s.x, y: s.y }), n.push({ x: s.x + s.radius / 2, y: s.y }), n.push({ x: s.x - s.radius / 2, y: s.y }), n.push({ x: s.x, y: s.y + s.radius / 2 }), n.push({ x: s.x, y: s.y - s.radius / 2 });}let s = n[0],i = k(n[0], e, t);for (let r = 1; r < n.length; ++r) {const o = k(n[r], e, t);o >= i && (s = n[r], i = o);}const r = l(n => -1 * k({ x: n[0], y: n[1] }, e, t), [s.x, s.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;let o = { x: r[0], y: r[1] },a = !0;for (let t = 0; t < e.length; ++t) if (f(o, e[t]) > e[t].radius) {a = !1;break;}for (let e = 0; e < t.length; ++e) if (f(o, t[e]) < t[e].radius) {a = !1;break;}if (!a) if (1 === e.length) o = { x: e[0].x, y: e[0].y };else {const n = { arcs: [] };h(e, n), o = 0 === n.arcs.length ? { x: 0, y: -1e3, disjoint: !0 } : 1 === n.arcs.length ? { x: n.arcs[0].circle.x, y: n.arcs[0].circle.y } : t.length ? C(e, []) : g(n.arcs.map(function (e) {return e.p1;}));}return o;}function R(e) {const t = { arcs: [] };h(e, t);const n = t.arcs;if (n.length <= 1) return null;{const e = ["M", n[0].p2.x, n[0].p2.y];for (let t = 0; t < n.length; ++t) {const s = n[t],i = s.circle.radius,r = s.width > i;e.push("A", i, i, 0, r ? 1 : 0, 1, s.p1.x, s.p1.y);}return { path: e.join(" ") };}}class N extends Event {constructor(e) {super("prop-change", { cancelable: !0, bubbles: !0, composed: !0 }), this.propName = "", this.propName = e;}}class $ extends HTMLElement {constructor() {super(...arguments), this._connected = !1, this._pendingEventListeners = [], this._size = 0, this._label = "", this._firePropChange = e => {this._connected && this.dispatchEvent(new N(e));};}get size() {return this._size;}set size(e) {e !== this._size && (this._size = e, this._firePropChange("size"));}get label() {return this._label;}set label(e) {e !== this._label && (this._label = e, this._firePropChange("label"));}attributeChangedCallback(e, t, n) {this[e] = n;}connectedCallback() {this._connected = !0, this.dispatchEvent(new Event("area-add", { bubbles: !0, composed: !0 }));}disconnectedCallback() {this._connected = !1;}_addPendingSvgListeners() {if (this._svgNode) {for (const e of this._pendingEventListeners) this._svgNode.addEventListener(e.type, e.listener, e.options);this._pendingEventListeners = [];}}setSvgNode(e) {this._svgNode = e, this._addPendingSvgListeners();}addEventListener(e, t, n) {this._pendingEventListeners.push({ type: e, listener: t, options: n }), this._addPendingSvgListeners();}removeEventListener(e, t, n) {this._svgNode && this._svgNode.removeEventListener(e, t, n);}}const E = "http://www.w3.org/2000/svg",L = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];class P extends HTMLElement {constructor() {super(), this._connected = !1, this._config = { height: 350, width: 600 }, this._areas = [], this._areaMap = new Map(), this._circleList = new Set(), this._circleMap = new Map(), this._nList = new Set(), this._nMap = new Map(), this._renderRequestPending = !1, this._areaChangeHandler = e => {e.stopPropagation(), this._requestRender();}, this._root = this.attachShadow({ mode: "open" }), this._root.innerHTML = '\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n      }\n      * {\n        box-sizing: border-box;\n      }\n      svg {\n        display: block;\n      }\n      #labels {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        pointer-events: none;\n      }\n      #labels label {\n        position: absolute;\n        top: 0;\n        left: 0;\n        user-select: none;\n        font-size: var(--venn-label-size, 15px);\n        font-family: var(--venn-label-font-family, system-ui, sans-serif);\n        font-weight: var(--venn-label-font-weight, 400);\n      }\n    </style>\n    <svg></svg>\n    <div id="labels"></div>\n    ';}static get observedAttributes() {return ["width", "height"];}attributeChangedCallback(e, t, n) {switch (e) {case "width":this.width = +n;break;case "height":this.height = +n;}}get width() {return this._config.width || 600;}set width(e) {this._config.width !== e && (this._config.width = e, this._requestRender());}get height() {return this._config.height || 350;}set height(e) {this._config.height !== e && (this._config.height = e, this._requestRender());}connectedCallback() {this._connected = !0, this.addEventListener("area-add", this._areaChangeHandler), this.addEventListener("prop-change", this._areaChangeHandler), this._requestRender();}disconnectedCallback() {this._connected = !1;}_areaKey(e) {return [...e.sets].sort().join(",");}_requestRender() {this._connected && !this._renderRequestPending && (this._renderRequestPending = !0, setTimeout(() => {try {if (this._connected) {const e = [],t = this.children;for (let n = 0; n < t.length; n++) if (t[n] instanceof $) {const s = t[n].computeAreas();s && s.length && e.push(...s);}this._renderData(e);}} finally {this._renderRequestPending = !1;}}, 0));}_findSubsets(e, t, n, s, i, r, o) {if (i === r) {const e = [];for (let n = 0; n < r; n++) e.push(t[n]);o.push(e);}for (let a = n; a <= s && s - a + 1 >= r - i; a++) t[i] = e[a], this._findSubsets(e, t, a + 1, s, i + 1, r, o);}_renderData(e) {if (this._connected) {e = e || [], this._areas = e, this._areaMap.clear(), e.forEach(e => {this._areaMap.set(this._areaKey(e), e), e.size || (1 === e.sets.length ? e.size = 10 : e.sets.length > 1 && (e.size = 2));});for (const e of this._areas) {const t = e.sets.length;if (t > 2) {const n = [];for (let s = 2; s < t; s++) {const i = new Array(s);this._findSubsets(e.sets, i, 0, t - 1, 0, s, n);}for (const t of n) {const n = t.join(",");if (!this._areaMap.has(n)) {const s = { sets: [...t], size: e.size };this._areas.push(s), this._areaMap.set(n, s);}}}}this._render();}}get _svg() {return this.__svg || (this.__svg = this._root.querySelector("svg")), this.__svg;}get _labels() {return this.__labels || (this.__labels = this._root.querySelector("#labels")), this.__labels;}_renderLabel(e, t, n, s, i) {const r = this._labels;let o = n.labelNode;if (e.label) {o || (o = document.createElement("label"), n.labelNode = o, r.appendChild(o)), o.style.color = `var(--venn-label-${this._areaKey(e).toLowerCase().replace(/,/g, "-")}-color, var(--venn-label-color, ${s}))`, o.textContent = e.label;const a = t.get(this._areaKey(e)) || { x: 0, y: 0 };o.style.transform = `translate3d(-50%, -50%, 0) translate3d(${a.x}px, ${a.y}px, 0px)`, o.style.maxWidth = i ? `${i}px` : "12em";} else o && (r.removeChild(o), n.labelNode = void 0);}_render() {const e = this._svg;e.setAttribute("width", `${this._config.width || 600}`), e.setAttribute("height", `${this._config.height || 350}`);const { circles: t, textCenters: n } = M(this._areas, this._config),s = new Set(),i = new Set();let r = 0;const o = () => {const e = L[r++];return r >= L.length && (r = 0), e;};for (const i in t) {const r = t[i];let a = this._circleMap.get(i);const l = `circle-${i.toLowerCase().replace(/\s/g, "")}`;if (a) this._circleList.delete(a);else {const t = e.ownerDocument.createElementNS(E, "g"),n = e.ownerDocument.createElementNS(E, "circle"),s = e.ownerDocument.createElementNS(E, "style");t.appendChild(s), t.appendChild(n), e.appendChild(t), a = { id: i, circle: r, circleNode: n, groupNode: t, styleNode: s }, this._circleMap.set(i, a);}s.add(a);const { groupNode: h, circleNode: c, styleNode: f } = a,u = o();c.setAttribute("id", l), h.setAttribute("transform", `translate(${r.x} ${r.y})`), c.setAttribute("r", `${r.radius}`), f.textContent = `\n#${l} {\n  fill: var(--venn-${l}-fill, ${u});\n  fill-opacity: var(--venn-${l}-fill-opacity, var(--venn-circle-fill-opacity, 0.25));\n  stroke: var(--venn-${l}-stroke, var(--venn-circle-stroke));\n  stroke-width: var(--venn-${l}-stroke-width, var(--venn-circle-stroke-width));\n}\n#${l}:hover {\n  fill: var(--venn-hover-${l}-fill, var(--venn-${l}-fill, ${u}));\n  fill-opacity: var(--venn-hover-${l}-fill-opacity, var(--venn-hover-circle-fill-opacity, var(--venn-${l}-fill-opacity, var(--venn-circle-fill-opacity, 0.25))));\n  stroke: var(--venn-hover-${l}-stroke, var(--venn-hover-circle-stroke, var(--venn-${l}-stroke, var(--venn-circle-stroke))));\n  stroke-width: var(--venn-hover-${l}-stroke-width, var(--venn-hover-circle-stroke-width, var(--venn-${l}-stroke-width, var(--venn-circle-stroke-width))));\n}\n      `;const d = this._areaMap.get(i);if (d) {d.component && d.component.setSvgNode(a.groupNode);const e = Math.max(100, 2 * a.circle.radius * .6);this._renderLabel(d, n, a, u, e);}}for (const e of this._circleList) {this._circleMap.delete(e.id);const t = e.groupNode.parentElement;t && t.removeChild(e.groupNode);}this._circleList = s;const a = [];for (const e of this._areas) if (e.sets.length > 1) {const t = R(e.sets.map(e => {var t;return null === (t = this._circleMap.get(e)) || void 0 === t ? void 0 : t.circle;}).filter(e => !!e));t && a.push({ sets: [...e.sets], path: t.path, size: e.size });}a.sort((e, t) => e.sets.length === t.sets.length ? t.size - e.size : e.sets.length - t.sets.length);for (const t of a) {const s = this._areaKey(t),r = `intersection-${s.toLowerCase().replace(/,/g, "-")}`;let o = this._nMap.get(s);if (o) this._nList.delete(o);else {const n = e.ownerDocument.createElementNS(E, "g"),i = e.ownerDocument.createElementNS(E, "path"),r = e.ownerDocument.createElementNS(E, "style");n.appendChild(r), n.appendChild(i), e.appendChild(n), o = { id: s, sets: [...t.sets], path: t.path, size: t.size, groupNode: n, pathNode: i, styleNode: r }, this._nMap.set(s, o);}i.add(o);const { groupNode: a, styleNode: l, pathNode: h } = o;a.style.fillOpacity = "0", h.setAttribute("id", r), h.setAttribute("d", `${o.path}`), l.textContent = `\n#${r} {\n  stroke: var(--venn-${r}-stroke, var(--venn-intersection-stroke));\n  stroke-width: var(--venn-${r}-stroke-width, var(--venn-intersection-stroke-width));\n}\n#${r}:hover {\n  stroke: var(--venn-hover-${r}-stroke, var(--venn-hover-intersection-stroke, var(--venn-${r}-stroke, var(--venn-intersection-stroke))));\n  stroke-width: var(--venn-hover-${r}-stroke-width, var(--venn-hover-intersection-stroke-width, var(--venn-${r}-stroke-width, var(--venn-intersection-stroke-width))));\n}\n      `;const c = this._areaMap.get(s);c && (c.component && c.component.setSvgNode(o.groupNode), this._renderLabel(c, n, o, ""));}for (const e of this._nList) {this._nMap.delete(e.id);const t = e.groupNode.parentElement;t && t.removeChild(e.groupNode);}this._nList = i;}}customElements.define("venn-diagram", P);class I extends $ {constructor() {super(...arguments), this._name = "", this._size = 10;}static get observedAttributes() {return ["name", "size", "label"];}get name() {return this._name;}set name(e) {e !== this._name && (this._name = e, this._firePropChange("name"));}computeAreas() {const e = [{ sets: [this.name], size: this.size, label: this.label, component: this }],t = this.children;let n = 0;for (let e = 0; e < t.length; e++) t[e] instanceof I && n++;for (let s = 0; s < t.length; s++) if (t[s] instanceof $) {const i = t[s];if (i.size >= this.size) switch (n) {case 0:case 1:i.size = this.size / 2;break;default:i.size = this.size / (2 * (n + 1));}const r = i.computeAreas();if (r && r.length) for (const t of r) e.push(t), e.push({ sets: [this.name, ...t.sets], size: Math.min(this.size, t.size) });}return e;}}customElements.define("venn-set", I);class S extends $ {constructor() {super(...arguments), this._sets = [], this._size = 2;}static get observedAttributes() {return ["sets", "size", "label"];}get sets() {return [...this._sets];}set sets(e) {this._sets = "string" == typeof e ? e.trim().split(" ").filter(e => !!e) : [...e], this._firePropChange("sets");}attributeChangedCallback(e, t, n) {"sets" === e ? this.sets = n : super.attributeChangedCallback(e, t, n);}computeAreas() {return this.sets.length > 1 ? [{ sets: [...this.sets].sort(), size: this.size, label: this.label, component: this }] : [];}}customElements.define("venn-n", S);export { P as VennDiagram, S as VennIntersection, I as VennSet };